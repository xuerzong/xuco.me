---
title: 如何正确的保存流式消息
description: 最近搞了一个ChatGPT镜像站，为了保证消息能够正确地保存到数据库，尝试了不同的几种方案，颇费脑筋。
category: 编程笔记
tags:
  - 编程
  - 前端
date: '2023-06-12'
---

最近搞了一个ChatGPT镜像站，为了保证消息能够正确地保存到数据库，尝试了不同的解决方案，颇费脑筋。

## 问题描述

对于服务器返回的流式消息，需要不间断的调接口同步给数据库，在这个过程中既要保证**即时的数据同步**，也要保证**较少的资源占用**。

为何不用防抖或者节流？

### 防抖

> 防抖：触发事件在规定的 `n` 秒时间后执行，期间如果重复触发，则重新计时

如果使用防抖，对于短时间内不断从服务端接收的流式消息，存在整个过程只执行了最后一次 `save` 函数的情况。在这种情况下（复现率 100%）如果用户突然**刷新或者离开**页面，那么当前消息并不会同步至数据库（为空）。

上述情况和我们在拿取到完整的消息后再发送 `save` 请求表现一致，这不是我们想要的。

### 节流

> 节流：触发事件在规定的 `n` 秒时间内只执行一次，无论触发多少次

如果使用节流，我们能够不间断向服务器发送 `save` 请求，并且能够控制发送频率，节约网络资源。但是，现在存在两个问题：

1. 当客户端接收到最后一个内容，并且此时还在节流的 `n` 秒内（定时器未结束），那么当我们触发 `save` 函数时并不会被响应，然后导致保存消息不完整。

![not-response-the-last-function](/static/assets/images/how-to-save-streaming-messages/not-response-the-last-function.png)

2. 当网络有延迟时，对于最后几个请求 `x - 1`、`x`...可能会存在第 `x - 1` 个请求响应比第 `x` 个请求响应慢，即最后的保存结果为第 `x - 1` 个请求。（这个问题与节流无关，只要是连续不断的请求接口都会存在这种情况）。

![response-time-delay](/static/assets/images/how-to-save-streaming-messages/response-time-delay.png)

## 解决方案

在思考之后，想到了一种解决方案：

1. 为了解决使用节流时出现的**问题1**，我们可以缓存所有的函数触发，当定时器结束后，再从缓存中拿到最近一次函数的触发。

![function-cache](/static/assets/images/how-to-save-streaming-messages/function-cache.png)

2. 为了解决使用节流时出现的**问题2**，我们可以在上一次函数执行完成后，再去执行下一个函数；

![next-function](/static/assets/images/how-to-save-streaming-messages/next-function.png)

具体流程实现如下：

1. 当触发事件时，我们将其 `arguments` 放入 `argsQueue`；
2. 若上一次执行已经完成并且 `argsQueue` 不为空，则从 `argsQueue` 中拿取最后一组 `argments`（即最近一次触发事件的 `arguments`），将其作为**形参**执行函数；否则，则直接返回；
3. 等待函数执行完毕，重复步骤2。

```typescript
export function lastCallback<T extends (...args: any) => ReturnType<T>>(
  callback: T
) {
  let argsQueue: any[] = []
  let isRunning = false

  const run = async () => {
    if (!argsQueue.length || isRunning) return

    const currentArgs = argsQueue[argsQueue.length - 1]
    argsQueue = []
    isRunning = true
    await callback(...currentArgs)
    isRunning = false
    run()
  }

  const returnCallback = ((...args: any) => {
    argsQueue.push([...args])
    run()
  }) as T

  return returnCallback
}
```

```typescript
function saveFunc (content: string) { /* ... */ }

const saveLastCallback = lastCallback(saveFunc)

saveLastCallback(content)
```

为了能够节约网络资源，我们仍能够对上述代码进行优化，即在上一次函数执行完成后，等待 `n` 秒，再执行下一个函数。需要注意的是，因为用到了定时器，所以在组件销毁的时候一定要记得清除定时器，避免内存泄漏。

```typescript
export function lastCallback<T extends (...args: any) => ReturnType<T>>(
  callback: T
) {
  // ...
  const run = async () => {
    // ...
    await callback(...currentArgs)
    setTimeout(() => { isRunning = false }, 300);
  }
  // ...
}
```

## 结语

当然，这不是解决这个问题的唯一方案，只是个人针对当前应用场景的技术思考。

针对这篇文章所讲述的解决方案，我将其封装成了一个通用的 `React Hooks`， 大家有兴趣的可以看一看源码 [use-last-callback](https://github.com/ninepielabs/use-last-callback)。